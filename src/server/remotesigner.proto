syntax = "proto3";

package remotesigner;

service Signer {
  rpc Ping(PingRequest)
    returns (PingReply);

  rpc Init (InitRequest)
    returns (InitReply);

  // BOLT #2 - Peer Protocol
  rpc NewChannel (NewChannelRequest)
    returns (NewChannelReply);

  // BOLT #2 - Channel Close
  rpc SignMutualCloseTx (SignMutualCloseTxRequest)
    returns (SignMutualCloseTxReply);

  // BOLT #2 - Message Retransmission
  rpc CheckFutureSecret (CheckFutureSecretRequest)
    returns (CheckFutureSecretReply);
  
  // BOLT #3 - Key Derivation
  rpc GetChannelBasepoints (GetChannelBasepointsRequest)
    returns (GetChannelBasepointsReply);
    
  // BOLT #3 - Per-commitment Secret Requirements
  rpc GetPerCommitmentPoint (GetPerCommitmentPointRequest)
    returns (GetPerCommitmentPointReply);

  // BOLT #3 - Funding Transaction
  rpc SignFundingTx (SignFundingTxRequest)
    returns (SignFundingTxReply);
    
  // BOLT #3 - Commitment Transaction
  rpc SignRemoteCommitmentTx (SignRemoteCommitmentTxRequest)
    returns (SignRemoteCommitmentTxReply);

  // BOLT #3 - Commitment Transaction
  rpc SignCommitmentTx (SignCommitmentTxRequest)
    returns (SignCommitmentTxReply);
    
  // BOLT #3 - HTLC Outputs
  rpc SignLocalHTLCTx (SignLocalHTLCTxRequest)
    returns (SignLocalHTLCTxReply);
    
  // BOLT #5 - Unilateral Close Handling
  rpc SignDelayedPaymentToUs (SignDelayedPaymentToUsRequest)
    returns (SignDelayedPaymentToUsReply);
    
  // BOLT #3 - HTLC Outputs
  rpc SignRemoteHTLCTx (SignRemoteHTLCTxRequest)
    returns (SignRemoteHTLCTxReply);

  // BOLT #3 - HTLC Outputs
  rpc SignRemoteHTLCToUs (SignRemoteHTLCToUsRequest)
    returns (SignRemoteHTLCToUsReply);
    
  // BOLT #5 - Unilateral Close Handling
  rpc SignPenaltyToUs (SignPenaltyToUsRequest)
    returns (SignPenaltyToUsReply);

  // BOLT #7 - channel_announcement
  rpc SignChannelAnnouncement (SignChannelAnnouncementRequest)
    returns (SignChannelAnnouncementReply);

  // BOLT #7 - node_announcement
  rpc SignNodeAnnouncement (SignNodeAnnouncementRequest)
    returns (SignNodeAnnouncementReply);

  // BOLT #7 - channel_update
  rpc SignChannelUpdate (SignChannelUpdateRequest)
    returns (SignChannelUpdateReply);

  // BOLT #8 - Authenticated Key Agreement Handshake
  rpc ECDH (ECDHRequest)
    returns (ECDHReply);

  // BOLT #11 - Invoice Protocol
  rpc SignInvoice (SignInvoiceRequest)
    returns (SignInvoiceReply);

  // BOLT #?? - Sign Message
  rpc SignMessage (SignMessageRequest)
    returns (SignMessageReply);
}

service Version {
  rpc Version (VersionRequest) returns (VersionReply);
}

// ----------------------------------------------------------------

message PingRequest {
  string message = 1;
}

message PingReply {
  string message = 1;
}

// Initialize a new Lightning node
message InitRequest {
  ChainParams chainparams = 1;

  // Developer field: set the HSM secret rather than generate it on the signer side.
  // Only allowed if this is using a non-production network.
  Secret hsm_secret = 100;
}

message InitReply {
  NodeId node_id = 1;
}

// Initialize a new channel
// TODO provide remote keys and basepoints in a new ChannelAcceptedRequest call
message NewChannelRequest {
  NodeId node_id = 1;

  // optional, will be pseudo-randomly generated if missing
  ChannelNonce channel_nonce = 2;

  // in satoshis
  uint64 channel_value = 3;
}

message NewChannelReply {
  ChannelNonce channel_nonce = 1;
}

// Sign a happy path mutual close transaction
message SignMutualCloseTxRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  // Deprecated, should be provided in NewChannelRequest
  PubKey remote_funding_pubkey = 4;
}

message SignMutualCloseTxReply {
  BitcoinSignature signature = 1;
}

// Check if the remote really knows a secret that we haven't generated since being
// restored from backup.  This proves to us that the state of the channel is at least
// at commitment number `n + 1`
message CheckFutureSecretRequest {
  NodeId node_id = 1;

  ChannelNonce channel_nonce = 2;

  // commitment number
  uint64 n = 3;

  // our secret that we haven't generated since being restored from backup, but the remote claims
  // is part of our shachain
  Secret suggested = 4;
}

message CheckFutureSecretReply {
  bool correct = 1;
}

// Get the basepoints and public keys specific to an accepted channel
message GetChannelBasepointsRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;
}

message GetChannelBasepointsReply {
  Basepoints basepoints = 1;
}

// Get the per-commitment point for a specific commitment number
message GetPerCommitmentPointRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;

  // commitment number
  uint64 n = 3;
}

message GetPerCommitmentPointReply {
  PubKey per_commitment_point = 1;

  // The revocation of the secret of the n-2 commitment, or None if n < 2
  Secret old_secret = 2;
}

// Sign a funding tx for this channel
// The channel must have been accepted
message SignFundingTxRequest {
  NodeId node_id = 1;
  
  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;
}

message SignFundingTxReply {
  // A witness stack for each of our inputs.  For inputs that are not ours, the element is None.
  repeated WitnessStack witnesses = 1;
}

// Sign the remote commitment
message SignRemoteCommitmentTxRequest {
  NodeId node_id = 1;
  
  ChannelNonce channel_nonce = 2;

  // TODO deprecate these two and move to specifying all the information that is required to rebuild the tx
  Transaction tx = 3;

  // one per transaction output.  empty array for p2pkh.
  // TODO consider moving this inside Transaction
  repeated bytes output_witscripts = 6;

  // TODO deprecated the next three fields and move to ChannelAccepted
  PubKey remote_funding_pubkey = 4;

  PubKey remote_per_commit_point = 5;

  bool option_static_remotekey = 7;
}

message SignRemoteCommitmentTxReply {
  BitcoinSignature signature = 1;
}

// Force close a channel by signing a local commitment tx.  The channel moves to closing state.
message SignCommitmentTxRequest {
  NodeId node_id = 1;
  
  ChannelNonce channel_nonce = 2;
    
  Transaction tx = 3;
  
  PubKey remote_funding_pubkey = 4;
}

message SignCommitmentTxReply {
  BitcoinSignature signature = 1;
}

// As part of a force close, sweep a local HTLC output hanging off the commitment tx
message SignLocalHTLCTxRequest {
  NodeId node_id = 1;

  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  uint64 n = 4;
  
  bytes witscript = 5;	// FIXME - find a better name
}

message SignLocalHTLCTxReply {
  BitcoinSignature signature = 1;
}

// As part of a force close, sweep the delayed to local output hanging off the commitment tx
message SignDelayedPaymentToUsRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;
  
  uint64 n = 4;
  
  bytes witscript = 5;	// FIXME - find a better name
}

message SignDelayedPaymentToUsReply {
  BitcoinSignature signature = 1;
}

// Sign a remote HTLC tx hanging off the remote commitment tx
message SignRemoteHTLCTxRequest {
  NodeId node_id = 1;

  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  PubKey remote_per_commit_point = 4;

  bytes witscript = 5;
}

message SignRemoteHTLCTxReply {
  BitcoinSignature signature = 1;
}

// Sweep a remote HTLC to us
message SignRemoteHTLCToUsRequest {
  NodeId node_id = 1;

  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  PubKey remote_per_commit_point = 4;

  bytes witscript = 5;
}

message SignRemoteHTLCToUsReply {
  BitcoinSignature signature = 1;
}

// Sign a penalty sweep of a remote to_local the peer has revoked
message SignPenaltyToUsRequest {
  NodeId node_id = 1;
    
  ChannelNonce channel_nonce = 2;

  Transaction tx = 3;

  Secret revocation_secret = 4;	// FIXME - is this remembered instead of passed?

  bytes witscript = 5;	// FIXME - find a better name
}

message SignPenaltyToUsReply {
  BitcoinSignature signature = 1;
}

// Sign a channel announcement
message SignChannelAnnouncementRequest {
  NodeId node_id = 1;
  
  ChannelNonce channel_nonce = 2;

  // Channel announcement message in BOLT-7 serialization
  bytes channel_announcement = 3;
}

message SignChannelAnnouncementReply {
  ECDSASignature node_signature = 1;

  ECDSASignature bitcoin_signature = 2;
}

// Sign node announcement message
message SignNodeAnnouncementRequest {
  NodeId node_id = 1;

  // announcement message in BOLT-7 format
  bytes node_announcement = 2;
}

message SignNodeAnnouncementReply {
  ECDSASignature signature = 1;
}

// Sign channel update message
message SignChannelUpdateRequest {
  // https://github.com/lightningnetwork/lightning-rfc/blob/master/07-routing-gossip.md#the-channel_update-message
  
  NodeId node_id = 1;

  // Portion of the channel_update message which requires signing
  // (skip the message type and the signature field, 66 byte offset).
  // In BOLT-7 format
  bytes channel_update = 2;
}

message SignChannelUpdateReply {
  ECDSASignature signature = 1;
}

// Perform ECDH for p2p communication purposes
message ECDHRequest {
  NodeId node_id = 1;

  // The ephemeral pubkey of the peer
  PubKey point = 2;
}

message ECDHReply {
  Secret shared_secret = 1; // 32 bytes
}

// Sign an invoice with the node secret key
message SignInvoiceRequest {
  NodeId node_id = 1;

  bytes data_part = 2;

  string human_readable_part = 3;
}

message SignInvoiceReply {
  ECDSARecoverableSignature signature = 1;
}

// Sign an ad-hoc message with the node secret key
message SignMessageRequest {
  NodeId node_id = 1;

  bytes message = 2;
}

message SignMessageReply {
  ECDSARecoverableSignature signature = 1;
}

message VersionRequest {
}

message VersionReply {
  string version_string = 1;
  uint32 major = 2;
  uint32 minor = 3;
  uint32 patch = 4;
  string prerelease = 5;
  string build_metadata = 6;
}

// ----------------------------------------------------------------

// Specify the network (e.g. testnet, mainnet)
message ChainParams {
  string network_name = 1;
}

// Compressed ECDSA public key in DER format derived from the node secret
message NodeId {
  bytes data = 1;
}

// A client-side unique ID for the channel, not necessarily related to the BOLT temporary/permanent node ID
message ChannelNonce {
  bytes data = 1;
}

// Compressed ECDSA public key in DER format
message PubKey {
  bytes data = 1;
}

// 256-bit Secret, 32 bytes
// Can be used for revocation hash pre-image, shared secrets, etc.
message Secret {
  bytes data = 1;
}

// A Bitcoin serialized transaction with additional metadata if needed for signing and validation
message Transaction {
  // The raw bytes of the transaction to be signed.
  bytes raw_tx_bytes = 1;

  // A set of sign descriptors, for each input to be signed.
  // TODO the input amount for the commitment tx should be specified in NewChannel instead of here
  repeated SignDescriptor input_descs = 2;
  
  // A set of sign descriptors, for each output.
  repeated SignDescriptor output_descs = 3;
}

// Basepoints and funding pubkey for one side of a channel
message Basepoints {
  PubKey revocation = 1;
  PubKey payment = 2;
  PubKey htlc = 3;
  PubKey delayed_payment = 4;
  PubKey funding_pubkey = 5;
}

// DER encoded SECP256K1_ECDSA Signature
message ECDSASignature {
  bytes data = 1;
}

// Compact ECDSA signature (64 bytes) + recovery id (1 byte) = 65 bytes
message ECDSARecoverableSignature {
  bytes data = 1;
}

// DER encoded Bitcoin Signature
message BitcoinSignature {
  bytes data = 1;
}

// Witness stack item, for signing a segwit transaction
message WitnessStack {
  repeated bytes item = 1;
}

// ----------------------------------------------------------------

message KeyLocator {
  /// The index of the key being identified.
  int32 key_index = 2;
}

// A Bitcoin transaction output
message TxOut {
  /// The value of the output being spent.
  int64 value = 1;

  /// The script of the output being spent.
  bytes pk_script = 2;
}

message SignDescriptor {
  /**
     A descriptor that precisely describes *which* key to use for signing. This
     may provide the raw public key directly, or require the Signer to re-derive
     the key according to the populated derivation path.
  */
  KeyLocator key_loc = 1;

  // A description of the output being spent. The value and script MUST be provided.
  TxOut output = 5;
}

